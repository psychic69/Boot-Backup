Command to get the current information:

lsblk -b -P -o NAME,UUID,FSTYPE,SIZE,MOUNTPOINT,LABEL,TRAN
This is now bytes.  Will need bytes to gig conversion for human readable.


/dev/disk/by-uuid/

backup:  91FC-86D8
active:  D467-DF06

fatlabel /dev/sdXN "NEW_LABEL"

test:
    fatlabel /dev/disk/by-uuid/91FC-86D8 "UNRAID_DR"

    Current mountpoint is /boot and label UNRAID

fdisk -l /dev/sdh
fdisk -l /dev/disk/by-uuid/{UUID}
Disk /dev/sdh: 7.54 GiB, 8095006720 bytes, 15810560 sectors
Disk model: ATPCGeUSB
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xc3072e18

Device     Boot Start      End  Sectors  Size Id Type
/dev/sdh1         120 15810559 15810440  7.5G  b W95 FAT32

To format partition /dev/sdX1 to FAT32 with the volume label MYUSB:

Bash

mkfs.vfat -F 32 -n MYUSB /dev/sdX1
-F 32: Specifies the FAT32 filesystem (this is optional as mkfs.vfat usually defaults to FAT32 on modern USB sizes).

-n MYUSB: Sets the Volume Label. The video below provides a guide on fixing and replacing an Unraid USB flash drive, which often involves formatting and partitioning steps.

Remove boot flag just in case:
DEVICE="/dev/sda"
PARTITION_NUMBER=1

echo "Removing boot flag from ${DEVICE}${PARTITION_NUMBER}..."

# The '-s' flag makes parted non-interactive (script-friendly)
# The 'set' subcommand is used to toggle flags (on/off)
parted -s "$DEVICE" set "$PARTITION_NUMBER" boot off

if [ $? -eq 0 ]; then
    echo "Successfully removed boot flag from ${DEVICE}${PARTITION_NUMBER}."
else
    echo "Error: Failed to remove boot flag."
fi

To stop backup from accidental boot, ensure EFI root renamed EFI-   (this will still work w/ make_bootable)

PSEUDOCODE:

The labels for the array (current_drive_state) will be the first row from the file ./test-lsblk and will be loaded into variable current_drive_headers

    First function, initial_test

    1. load file ./test-lsblk  into an array (current_drive_state) ignoring the first row which is the header/   current drive headers will be used for lookup to index the column in the array. So the header location will dictate the column to index.
    2. Create a function print_partition_state which takes a row from the current drive state as input and prints the following:
        Drive location: [strip all characters before sd*.  Put in temp variable stripped_partition and then print as /dev/$stripped_partition]
        Current Mountpoint: MOUNTPOINT
        UUID: UUID
        File type: FSTYPE
        Current Label: LABEL
        Drive Size: SIZE
        File Type: TRAN
     a.  Add a function convert_bytes_to_human to convert SIZE from bytes to G (gigabytes) and have precision of 2 and have actual bytes  in (actual bytesunconverted) bytes 

    2. Check to see if there is one and only one LABEL (column 6) UNRAID and in NAME (col 1) the final digit is 1.
        
        a. If not, print all rows matching UNRAID, send them to function print_partition_state.    Print this error first: "Error: You have multiple partitions with the label: UNRAID.  You must only have one or the system may not boot properly.  Please resolve"
        b. exit with error
    3.  There is one partition with LABEL UNRAID.
       a. Print "The current booted environment is as follows"
       b. Send the current row index with LABEL UNRAID to print_partition_state

       c.  OK made it here make sure that the current booted UNRAID is at /boot.   If not error out and say  "Error:  Currently Label is UNRAID, however mount point is not /boot: $mountpoint"
-----------
         Add:  
     
    BOOT_SIZE=$(get_column_value "$boot_row" "SIZE")
    below the BOOT_MOUNT definition


    4. Scan the drives again from input file (test-lsblk) and look for partition label = "UNRAID_CLONE"
      a.  If it exists jump to function clone_backup{}   If it does not exist jumpt to function find_and_prepare_clone{}

    5.  Funtion find_and_prepare_clone():  (There is no partition with the name UNRAID_CLONE)
      a. Scan for drives with TRAN="usb" and LABEL != "UNRAID"
         If a drive is matched:
           1.  Check to see if the SIZE of the drive (not partition) > 0.95*$BOOT_SIZE
                if true, add to new array with all values with array name: clone_array
                  print partition table infor using: fdisk -l /dev/disk/by-uuid/$UUID from array
                  print disk information /dev/"NAME"  (not partition)
                  else
                    Send informational message "USB Drive: $UUID is too small to be used as a backup, size must be 95% or greater of human readable $BOOT_SIZE
                fi
        If there are zero drives in the array after scanning, ERROR out and log "There were no qualified USB availible backup drives found.  Please connect a new drive."
    
    6. Function clone_backup()
       Leave as holder--blank for now. 
  

       