Command to get the current information:

lsblk -b -P -o NAME,UUID,FSTYPE,SIZE,MOUNTPOINT,LABEL,TRAN
This is now bytes.  Will need bytes to gig conversion for human readable.


/dev/disk/by-uuid/

backup:  91FC-86D8
active:  D467-DF06


Remove boot flag just in case:
DEVICE="/dev/sda"
PARTITION_NUMBER=1

echo "Removing boot flag from ${DEVICE}${PARTITION_NUMBER}..."

# The '-s' flag makes parted non-interactive (script-friendly)
# The 'set' subcommand is used to toggle flags (on/off)
parted -s "$DEVICE" set "$PARTITION_NUMBER" boot off

if [ $? -eq 0 ]; then
    echo "Successfully removed boot flag from ${DEVICE}${PARTITION_NUMBER}."
else
    echo "Error: Failed to remove boot flag."
fi

To stop backup from accidental boot, ensure EFI root renamed EFI-   (this will still work w/ make_bootable)

PSEUDOCODE:

The labels for the array (current_drive_state) will be the first row from the file ./test-lsblk and will be loaded into variable current_drive_headers

    First function, initial_test

    1. load file ./test-lsblk  into an array (current_drive_state) ignoring the first row which is the header/   current drive headers will be used for lookup to index the column in the array. So the header location will dictate the column to index.
    2. Create a function print_partition_state which takes a row from the current drive state as input and prints the following:
        Drive location: [strip all characters before sd*.  Put in temp variable stripped_partition and then print as /dev/$stripped_partition]
        Current Mountpoint: MOUNTPOINT
        UUID: UUID
        File type: FSTYPE
        Current Label: LABEL
        Drive Size: SIZE
        File Type: TRAN
     a.  Add a function convert_bytes_to_human to convert SIZE from bytes to G (gigabytes) and have precision of 2 and have actual bytes  in (actual bytesunconverted) bytes 

    2. Check to see if there is one and only one LABEL (column 6) UNRAID and in NAME (col 1) the final digit is 1.
        
        a. If not, print all rows matching UNRAID, send them to function print_partition_state.    Print this error first: "Error: You have multiple partitions with the label: UNRAID.  You must only have one or the system may not boot properly.  Please resolve"
        b. exit with error
    3.  There is one partition with LABEL UNRAID.
       a. Print "The current booted environment is as follows"
       b. Send the current row index with LABEL UNRAID to print_partition_state

       c.  OK made it here make sure that the current booted UNRAID is at /boot.   If not error out and say  "Error:  Currently Label is UNRAID, however mount point is not /boot: $mountpoint"
-----------
         Add:  
     
    BOOT_SIZE=$(get_column_value "$boot_row" "SIZE")
    below the BOOT_MOUNT definition


    4. Scan the drives again from input file (test-lsblk) and look for partition label = "UNRAID_CLONE"
      a.  If it exists jump to function clone_backup{}   If it does not exist jumpt to function find_and_prepare_clone{}

    5.  Function find_and_prepare_clone():  (There is no partition with the name UNRAID_CLONE)
      a. Scan for drives with TRAN="usb" and LABEL != "UNRAID"
         If a drive is matched:
           1.  Check to see if the SIZE of the drive (not partition) > 0.95*$BOOT_SIZE
                if true, add to new array with all values with array name: clone_array
                  print partition table infor using: fdisk -l /dev/disk/by-uuid/$UUID from array
                  print disk information /dev/"NAME"  (not partition)
                  else
                    Send informational message "USB Drive: $UUID is too small to be used as a backup, size must be 95% or greater of human readable $BOOT_SIZE
                fi
        If there are zero drives in the array after scanning, ERROR out and log "There were no qualified USB availible backup drives found.  Please connect a new drive."

        b.  OK of the qualified USB drives

        c. Provide a list of the qualified USB drives in a menu using the dialog "Here are the qualified drive(s) to format to be the backup USB for the /boot system.  Choose the drive you would like.  Please type in the device name from the list"
          In the list for each drive(s) have Device Name: {device name}, Model: {Model}, Size: Size (bytes, human)
          The user must enter in the device name.  (ie sdi)
          Once the user enters in the device name check to see it matches a device in the qualifed list.  If they mess it up give them one more chance to enter the device name in correctly.  If not error out of the script
          Put up the warning "Be aware the device /dev/{DEVICE} will be formatted and wiped.  Are you sure you want to do this?  If so type FORMAT in all capitals"
          Have a dialog and see if the user enters "FORMAT".  If not give one more chance to enter correctly and if not exist from the script.

        d. Execute partition_device_new function and send in the /dev/{DEVICE} as the flag for the function.
        e. set global variables as follows:
            CLONE_DEVICE=/dev/{device} of the chosen qualified drive
        f. execute function clone_backup() and send as $1 $CLONE_DEVICE
        

    
    
    6. Function clone_backup{}
       Leave as holder--blank for now. 
  

       